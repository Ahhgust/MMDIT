# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' strings to ints
#'
#' This is a Rcpp implementation of R's
#' as.integer(as.factor(strings)) - 1
#'
#' ie, it converts strings into integers (0-based)
#' the conversion maintains the natural ordering
#' (the first string is 0, the next new string i 1, ... )
#'
#' returns number of unique elements
#'
#' @param s (vector of strings)
#' @param out (vector of integers; this is filled out by the method; same length as s)
#' @return number of distinct/unique strings
#' @export
str2int <- function(s, out) {
    .Call('_MMDIT_str2int', PACKAGE = 'MMDIT', s, out)
}

#' Estimates theta
#'
#' Estimate's the overall theta/fst as per:
#' doi: 10.1016/j.fsigen.2016.03.004
#'
#' In particular, this take in a vector of strings
#' and a vector of population labels:
#' eg:
#'
#' alleles <- c("A", "A", "G", "G")
#' pops <- c("CEU", "CEU", "YRI", "YRI")
#'
#' and it estimates Buckleton's FST
#' It returns a vector of length nJack+1
#' Index 1 in the vector is the overall FST
#' subsequent indexes are the jackknife estimates.
#' To get a upper bound on FST try:
#'
#' fst_buckleton(alleles, pops, nJack=1000, approximate=false) -> fsts
#' quantile(fsts[-1], 0.99)
#'
#' for a naive estimate of 99CI FST
#'
#' In general, Buckleton's estimator is perhaps a bit simple in implementation
#' e.g., it takes simple averages over population-pairs to estimate the overall FST
#' Also, it uses the number of pairwise differences to compute homozygosity/heterozygosity
#' (n*(n-1)) style.
#' The approximate option instead uses allele frequencies (which are stated as an approximation)
#' The major distinction here is that all singletons (haplotypes/allele seen once contribute nothing to
#' within-population homozygosity) when approximate is TRUE (they contribute 0 pairwise differences)
#' This makes sense if, say, all alleles/haplotype are UNIQUE (FST-> 0)
#'
#' It make less sense when sample sizes are small (like in the example)
#' This would imply that large sample sizes are needed
#'
#' @param alleles (vector of strings, 1 allele per haploid individual)
#' @param populations (vector of strings; population labels)
#' @param nJack (number of jackknifes)
#' @param approximate (boolean; treat the population as being infinite in size)
#'
#' @return Numeric vector of length nJack+1. overall FST is at index [[1]], nJack jackknife estimates follow
#'
#' @export
fst_buckleton <- function(alleles, populations, nJack = 0L, approximate = FALSE) {
    .Call('_MMDIT_fst_buckleton', PACKAGE = 'MMDIT', alleles, populations, nJack, approximate)
}

#' Global alignment of 2 strings
#'
#' This performs global pairwise alignment between a pair of sequences.
#' It returns the number of cigar operations
#' and the operations (M, I, D, optionally =/X if extended CIGARs are used)
#' (ops vector)
#' and the operation positions (opPos vector)
#'
#' Written by Heng Li with small tweaks by August Woerner
#'
#' @param Tseq (a string from the DNA alphabet)
#' @param Qseq (like Tseq, but different)
#' @param opPos (integer vector that is modified. It is the position of the cigar operation)
#' @param ops (these are the cigar operations themselves. there encoded as their integer representations, e.g., int('M')
#' @param sc_mch (the score for a match)
#' @param sc_mis (the penalty for a mismatch)
#' @param gapo (gap open penalty)
#' @param gape (gap extend penalty)
#' @param extended (changes M [Match or Mismatch] to =/X [Match or Mismatch, respectively] in the CIGAR)
#' @export
ksw2_gg_align <- function(Tseq, Qseq, opPos, ops, sc_mch = 1L, sc_mis = -2L, gapo = 2L, gape = 1L, extended = TRUE) {
    .Call('_MMDIT_ksw2_gg_align', PACKAGE = 'MMDIT', Tseq, Qseq, opPos, ops, sc_mch, sc_mis, gapo, gape, extended)
}

#' Computes a string from a difference encoding
#'
#' This takes the output from: ksw2_gg_align_df(Tseq, Qseq, ... ) (or other)
#' and the reference (Tseq)
#' and uses it to re-create Qseq.
#' The main advantage of this approach is that particular types
#' of mutations can be filtered, as well as variants that fall in
#' particular regions.
#' @param Tseq (the target sequence; e.g., the reference genome)
#' @param positions (the positions where the sequence differences are)
#' @param types (the types of events (0,1,2 for mismatch, deletions and insertions)
#' @param events (the nucleotides involved with the event)
#' @param initBuff (guess as to the final size of the query sequence. Overestimating is better than under)
#' @export
seqdiffs2seq <- function(Tseq, positions, types, events, initBuff = -1L) {
    .Call('_MMDIT_seqdiffs2seq', PACKAGE = 'MMDIT', Tseq, positions, types, events, initBuff)
}

